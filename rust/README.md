# Notes on the Rust implementation
Prior to implement a solution to the presented union find problem in Rust, I had vague knowledge of the language and its reputation (or rather notoriety) as a difficult to learn beast. After writing the solution in Rust, I must conclude that this reputation was well earned.

I dedicated quite some time to reading the [Rust book](https://doc.rust-lang.org/book/). This is an amazing learning resource, although it requires a huge time investment. As of writing this, I still do not have a solid grasp on the concept of lifetime.

The union find algorithm was probably the worst possible first project to try out Rust. The experience of writing it was painful and demoralizing. I am 99% certain that the implementation presented in the python version is impossible to be directly translated into Rust code without using `unsafe` block abundantly.

On the plus side, this has forced me to redesign the solution for a more elegant one. I solved the problem as follows:
- the union find data structure is now represented as two dynamic arrays (`std::Vec`). One holds the points, the other one holds indices of parents. Imagine the following assertion holds true: `parents[5] == 6`. This means that the point which is at index 5 in the `points` array has a parent which is at index 6 in the `points` array.
- to check the existence of a point in the union find, the `points` array must be iterated. This is slower than checking for existence in a map. Adding a set to keep track of existing points should make lookups much faster.
- to add a new point to the union find data structure, this point is simply appended to the end of the `points` array and a new entry is appended to the `parents` array.
- the logic to connect two points is unchanged

## Notes on the language itself
Rust made me angry on several occasions:
- I can understand the desire to keep the standard library lean, but I struggle to justify when basic functionality is missing and requires third party crates to be used. Such functionality include missing RNG (requires rand crate or similar), no scanf equivalent (requires scanf crate), missing number traits which makes writing basic algebra a chore (requires num crate). Sure, I could just use required crates. However, we should all remember the time when 13 lines of javascript dependency broke the internet. Please, do not misconstrue my argument. I am not against having dependencies. My point is that even the most basic programs written in Rust have a high likelihood of requiring them. Therefore I claim that the standard library should by slightly extended to include such core functionality. And yes, I know that everybody has a different definition of "core functionality". We can absolutely have that discussion. At the end of the day, however, it is obvious that the line between what to include and what not to include was not drawn in the correct spot for Rust's standard library and one day, we will have to deal with a lot of software that will break because of a single dependency that most of the Rust projects will be using at that time. This is a huge shame because Rust's dependency management is otherwise splendid.
- Lifetimes are ugly. This is subjective, though. I admit, I do not understand lifetimes enough to criticize them. I do not like that they are confused with generics, but there may be a good reason for it (I know the Rust book talks about this. I did not find the explanation satisfying).
- I was originally under the general impression that Rust is a safe C. It is not. It is a safe C++. Just like C++, it has its complexities. C is a tiny language and it absolutely has its appeal, especially compared to the tumorous disjointed mess that is C++ (I do not hate C++, I just prefer not to use it whenever possible). In my mind a good C replacement must be just as minimalist as C itself, but with a much stronger standard library (and obviously, it must have C's speed). Oh, if only Go had manual memory management...

Rust overall was a pleasant language to use. Not quite as pleasant as Go, but pleasant nonetheless. I must stress once again, that Rust's dependency management is top notch. I love the error handling, it is superior to Go's. I will continue to learn Rust and, hopefully, become more proficient with it.